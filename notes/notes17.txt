================================================================================
S17: BUILDING AN HTTP SERVER - COMPREHENSIVE NOTES
================================================================================

OVERVIEW:
This section introduces HTTP server development in Go using the standard
library's net/http package. We transition from console I/O to serving content to
web clients (browsers) over HTTP. Go's standard library provides straightforward
APIs for building web servers without requiring external frameworks.

Key Topics Covered:
- HTTP package and core functions
- ListenAndServe function and server startup
- HandleFunc for route handling
- HTTP handler function signatures
- ResponseWriter and Request objects
- Basic routing and URL pattern matching
- Automatic 404 handling
- Server lifecycle and control

================================================================================
1. THE HTTP PACKAGE AND LISTENANDSERVE
================================================================================

The http package in Go provides essential functions for HTTP server development.
The primary function for starting a web server is ListenAndServe, which is an
exported function from the net/http package.

Purpose:
- ListenAndServe starts a web server and begins listening for incoming connections
- Takes an address:port combination and a handler as arguments
- Blocks execution until the server terminates (typically never, unless error)
- Returns an error value if the server cannot start

Signature:
    func ListenAndServe(addr string, handler Handler) error

From main.go (lines 28-33):
    func main() {
        http.HandleFunc("/hey", func(w http.ResponseWriter, r *http.Request) {
            w.Write([]byte("This is the /hey route."))
        })
        
        err := http.ListenAndServe(":3333", nil)
        if err != nil {
            fmt.Println("Error : ", err.Error())
        }
    }

The function receives:
1. Address parameter (":3333" in the example) - Opens a port in the operating
   system for incoming TCP connections
2. Handler parameter (nil in this example) - The handler determines which routes
   are handled. nil uses the default multiplexer with registered routes.

Key Concepts:
- The address can be just ":port" (listens on all network interfaces) or
  "ip:port" to specify a particular IP address
- Common port for HTTP is 80, HTTPS is 443, but any valid port number works
- Some ports are reserved by the operating system (0-1024 are well-known ports)
- If the port is already in use, ListenAndServe returns an error


================================================================================
2. UNDERSTANDING THE ADDRESS:PORT SYNTAX
================================================================================

The first argument to ListenAndServe specifies where the server should listen
for incoming connections.

Syntax Variations:
1. ":port" - Listen on all network interfaces on the specified port
   Example: ":3333" listens on port 3333 on all available network connections

2. "ip:port" - Listen only on the specified IP address and port
   Example: "localhost:8080" or "127.0.0.1:8080"

3. "hostname:port" - Listen on a specific hostname
   Example: "example.com:80"

Common Ports:
- HTTP default: port 80
- HTTPS default: port 443
- Development: ports 3000-9999 (not reserved)
- Database services: 5432 (PostgreSQL), 3306 (MySQL), 27017 (MongoDB)

Best Practices:
- For development, use high-numbered ports like 3333 or 8080
- Ports below 1024 require administrator/root privileges
- Include error handling in case the port is already in use or reserved

Example Error Handling:
    err := http.ListenAndServe(":3333", nil)
    if err != nil {
        fmt.Println("Error : ", err.Error())
    }

This allows the server to gracefully report port conflicts or other startup issues.


================================================================================
3. HTTP HANDLER FUNCTION SIGNATURES
================================================================================

In Go's http package, a handler is any function that implements the http.Handler
interface. The most common way to define handlers is using HandleFunc with a
specific function signature.

Handler Function Signature:
    func(w http.ResponseWriter, r *http.Request)

Parameters:
1. w http.ResponseWriter (named 'w' by convention)
   - An interface that provides methods to write the HTTP response
   - Allows setting headers and sending response body to the client
   - Typically has Write method to send []byte data to the response

2. r *http.Request (named 'r' by convention, pointer to Request struct)
   - Represents the incoming HTTP request from the client
   - Contains information about the request: URL, headers, body, method, etc.
   - Is a pointer because it can be large and modified by handlers

From main.go (lines 25-27):
    http.HandleFunc("/hey", func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("This is the /hey route."))
    })

Key Observations:
- Handler functions are anonymous functions (lambdas) defined inline
- Order of parameters: ResponseWriter first, then Request (may seem backwards)
- The ResponseWriter is where you write the response that goes to the client
- The Request contains all information about what the client asked for


================================================================================
4. HANDLEFUNC: REGISTERING ROUTES AND HANDLERS
================================================================================

HandleFunc is the function used to register URL patterns with handler functions.
It's part of Go's default routing/multiplexing system without requiring external
libraries.

Signature:
    func HandleFunc(pattern string, handler func(ResponseWriter, *Request))

Parameters:
1. pattern string - The URL path pattern to match
2. handler - A function with the handler signature (ResponseWriter, *Request)

Functionality:
- Registration happens when HandleFunc is called (during server startup phase)
- Go's multiplexer matches incoming requests to registered patterns
- If a request URL matches a pattern, the associated handler is called
- Multiple patterns can be registered before ListenAndServe

From main.go (lines 25-33):
    http.HandleFunc("/hey", func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("This is the /hey route."))
    })
    
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("Hello from '/' route"))
    })

Pattern Matching:
- "/" matches the root/home route
- "/hey" matches the /hey path specifically
- Patterns follow a routing system that intelligently matches URLs
- Go automatically handles 404s for unregistered paths

Registration Order:
- HandleFunc calls should occur before ListenAndServe
- Order of registration doesn't determine matching order
- More specific patterns should generally be registered before wildcards


================================================================================
5. WRITING RESPONSES WITH RESPONSEWRITER.WRITE()
================================================================================

The ResponseWriter interface provides the Write method to send response content
back to the client. The Write method requires a slice of bytes ([]byte).

Signature:
    func (w ResponseWriter) Write(b []byte) (int, error)

Returns:
- int: Number of bytes written
- error: Error if writing failed

String to []byte Conversion:
Since Write expects []byte, string literals must be converted using []byte():
    []byte("your string here")

From main.go (lines 26, 31):
    w.Write([]byte("This is the /hey route."))
    w.Write([]byte("Hello from '/' route"))

Important Details:
- The byte slice is sent directly to the HTTP client (browser)
- By default, the response is treated as plain text
- No explicit status code setting means HTTP 200 OK is used
- Multiple Write calls append to the response body

Common Usage Pattern:
1. Call w.Write with []byte("content") to send response
2. Content is accumulated in the response body
3. Response is sent to the client when handler function completes

Advanced ResponseWriter Methods:
- WriteHeader(statusCode int) - Set HTTP status code explicitly
- Header() http.Header - Access response headers (User-Agent, etc.)
- Flush() - Send response immediately (for streaming)

These methods aren't used in basic handlers but are important for more complex
server implementations.


================================================================================
6. THE DEFAULT MULTIPLEXER AND ROUTING SYSTEM
================================================================================

Go's http package includes a built-in multiplexer (mux) that handles routing
without requiring an external router library. This multiplexer is the default
handler when ListenAndServe receives nil as its second argument.

How It Works:
1. HandleFunc registers URL patterns with the default multiplexer
2. Incoming requests are matched against registered patterns
3. If a pattern matches, the associated handler is called
4. If no pattern matches, a 404 response is automatically sent

From main.go (line 33):
    err := http.ListenAndServe(":3333", nil)

The nil argument means "use the default multiplexer that has all the HandleFunc
registrations."

Smart Behavior:
- Pattern matching is intelligent (not just string comparison)
- More specific routes can coexist with general routes
- The router automatically determines which handler to call
- No configuration file needed; routing is code-based

Default 404 Handling:
If a request comes to a URL that has no registered handler:
- Server automatically returns HTTP 404 Not Found
- No explicit code needed for 404s
- Example: If only "/hey" and "/" are registered, request to "/hello" gets 404


================================================================================
7. SERVER STARTUP AND EXECUTION FLOW
================================================================================

When you run a Go server with ListenAndServe, the execution follows a specific
pattern that's important to understand.

Execution Flow:
1. main() function starts
2. HandleFunc calls register routes with the multiplexer
3. ListenAndServe(":3333", nil) is called
4. Server opens the port and begins listening
5. main() blocks indefinitely (doesn't return control to console)
6. Server waits for incoming HTTP requests
7. When requests arrive, handlers are called to process them

From main.go (lines 24-33):
    func main() {
        // Registration phase
        http.HandleFunc("/hey", func(w http.ResponseWriter, r *http.Request) {
            w.Write([]byte("This is the /hey route."))
        })
        
        http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
            w.Write([]byte("Hello from '/' route"))
        })
    
        // Server startup phase (blocks here)
        err := http.ListenAndServe(":3333", nil)
        // Code after this line doesn't run unless server stops
        if err != nil {
            fmt.Println("Error : ", err.Error())
        }
    }

Key Point: BLOCKING BEHAVIOR
- ListenAndServe blocks execution indefinitely
- The console prompt never returns while the server runs
- Server must be manually interrupted using Ctrl+C to stop it
- This is expected behavior for production servers (always running)

Lifecycle:
1. Startup: Server opens port and registers itself to OS
2. Running: Server continuously listens for connections and handles requests
3. Termination: Ctrl+C sends interrupt signal, stopping the server

From qna.txt:
"ListenAndServe will actually return a possible error option. If for some
reason, for example, the port is already open in use, or it's not the port
that you can actually open because there are some ports reserved for the OS."


================================================================================
8. ERROR HANDLING FOR SERVER STARTUP
================================================================================

ListenAndServe can fail for several reasons. Proper error handling ensures
your server gracefully reports problems.

Common Errors:
1. Port Already in Use: Another process is using the specified port
2. Permission Denied: Port number is reserved (< 1024) and run without elevation
3. Invalid Address: Malformed address:port syntax
4. Network Issues: System cannot bind to specified address

Error Handling Pattern:
    err := http.ListenAndServe(":3333", nil)
    if err != nil {
        fmt.Println("Error : ", err.Error())
    }

From main.go (lines 32-35):
    err := http.ListenAndServe(":3333", nil)
    if err != nil {
        fmt.Println("Error : ", err.Error())
    }

Error Messages:
- err.Error() converts the error to a string description
- Can be logged for debugging
- Can trigger alternative server startup on different port

Advanced Error Handling:
    err := http.ListenAndServe(":3333", nil)
    if err != nil {
        // Log error
        log.Printf("Failed to start server: %v", err)
        // Could retry on different port
        err = http.ListenAndServe(":3334", nil)
    }

This allows graceful degradation if the primary port is unavailable.


================================================================================
9. ANONYMOUS FUNCTIONS AS HTTP HANDLERS
================================================================================

The examples in main.go use anonymous functions (function literals) directly
as handlers passed to HandleFunc. This is idiomatic Go for simple handlers.

Syntax:
    func(w http.ResponseWriter, r *http.Request) {
        // Handler body
    }

From main.go (lines 25-31):
    http.HandleFunc("/hey", func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("This is the /hey route."))
    })
    
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("Hello from '/' route"))
    })

Advantages of Anonymous Functions:
1. Logic kept near where routes are registered
2. No need to define separate named functions
3. Clear relationship between pattern and handler implementation
4. Concise for simple handlers

Function Passing as Arguments:
- Go supports passing functions as arguments (first-class functions)
- HandleFunc's second parameter expects a function of specific signature
- Anonymous functions satisfy this expectation when defined inline

When to Use Anonymous Functions:
- Simple handlers with 2-5 lines of code
- One-off logic that won't be reused
- Quick prototyping and development

When to Use Named Functions:
- Complex handlers with 20+ lines of code
- Handlers used multiple times
- Better code organization in large projects


================================================================================
10. REQUEST AND RESPONSE CONCEPTS
================================================================================

Every HTTP interaction consists of a request (client to server) and a response
(server to client). The *http.Request and http.ResponseWriter represent these
in Go's HTTP server model.

Request (*http.Request):
- Contains all information about what the client asked for
- Includes URL, HTTP method (GET, POST), headers, body content
- Is a pointer because it can be large and contains mutable state
- Is provided automatically by the multiplexer

Response (http.ResponseWriter):
- Represents the response being built to send back to client
- Provides methods to write status codes, headers, and body
- Acts as an output interface to the HTTP client
- Must be used before completing handler execution

Flow:
    Client sends HTTP Request
            ↓
    Router dispatches to handler
            ↓
    Handler receives Request and ResponseWriter
            ↓
    Handler calls w.Write() with response body
            ↓
    Response is sent to client
            ↓
    Handler completes

Parameter Order:
The signature (ResponseWriter, *Request) might seem backwards (response first,
request second), but this is the established pattern in Go's http package.


================================================================================
11. BASIC ROUTING PATTERNS
================================================================================

Go's default multiplexer supports pattern-based routing without external libraries.
Understanding basic patterns allows building multi-route servers.

Root Route:
    http.HandleFunc("/", handler)
    - Matches the root/home path
    - Typically the default page shown at domain root
    - Example: localhost:3333/ shows homepage

Specific Path Routes:
    http.HandleFunc("/hey", handler)
    - Matches exactly the /hey path
    - Different from / because it's more specific
    - Example: localhost:3333/hey shows "hey" page

Multiple Routes:
    http.HandleFunc("/", homeHandler)
    http.HandleFunc("/about", aboutHandler)
    http.HandleFunc("/contact", contactHandler)
    - Each path can have its own handler
    - All registered before ListenAndServe
    - Multiplexer decides which handler based on request URL

From main.go (lines 25-31):
    http.HandleFunc("/hey", func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("This is the /hey route."))
    })
    
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("Hello from '/' route"))
    })

Automatic 404s:
- Requests to unregistered paths (e.g., /hello when only /hey and / registered)
- Server automatically returns 404 Not Found
- No code needed to implement 404 handling
- Default multiplexer handles this internally


================================================================================
12. RUNNING AND TESTING THE SERVER
================================================================================

Starting the Server:
    go run main.go

The server starts listening on port 3333 and blocks indefinitely.

Testing Endpoints:
Once server is running:
1. Browser: Navigate to http://localhost:3333/
   - Should show: "Hello from '/' route"

2. Browser: Navigate to http://localhost:3333/hey
   - Should show: "This is the /hey route."

3. Browser: Navigate to http://localhost:3333/anything
   - Should show: 404 Not Found (no handler registered)

Stopping the Server:
- Press Ctrl+C in the terminal where server is running
- Send interrupt signal to process
- Server gracefully shuts down

Testing with Command Line:
    curl http://localhost:3333/
    curl http://localhost:3333/hey
    curl http://localhost:3333/nonexistent

These curl commands perform HTTP requests from terminal without browser.

Common Issues:
1. "Address already in use" - Another server on port 3333, change port number
2. No response - Check server is actually running, look for console output
3. 404 on valid path - Handler not registered, check URL pattern matches exactly


================================================================================
KEY TAKEAWAYS
================================================================================

1. HTTP Server Basics:
   - http.ListenAndServe starts a web server on specified address:port
   - Second argument is handler; nil uses default multiplexer
   - Server blocks indefinitely until interrupted

2. Route Registration:
   - http.HandleFunc registers URL patterns with handler functions
   - Register all routes before calling ListenAndServe
   - Handler function signature: func(http.ResponseWriter, *http.Request)

3. Handler Execution:
   - When request arrives, multiplexer finds matching pattern
   - Associated handler function is called with ResponseWriter and Request
   - Handler uses w.Write([]byte()) to send response to client

4. Response Writing:
   - ResponseWriter.Write() takes []byte slice
   - Convert strings with []byte("string")
   - By default, status 200 OK is sent
   - Multiple Write calls append to response

5. Routing:
   - Default multiplexer intelligently matches patterns
   - More specific patterns can coexist with general patterns
   - Unregistered paths automatically return 404 Not Found
   - No complex routing library needed for basic applications

6. Anonymous Functions:
   - Handlers can be anonymous functions defined inline
   - Idiomatic for simple handlers (2-5 lines)
   - Keeps handler logic close to route registration

7. Error Handling:
   - Always check ListenAndServe return value for errors
   - Common errors: port in use, permission denied
   - Log errors for debugging

8. Server Lifecycle:
   - Registration phase: HandleFunc calls
   - Startup phase: ListenAndServe begins listening
   - Running phase: Server blocks, handling requests
   - Termination: Ctrl+C stops server

NEXT SECTION: s18_loggingAndWatchingServer
- Build on this foundation with server logging
- Add authentication and middleware patterns
- Learn to monitor server behavior
================================================================================
