================================================================================
SECTION 12: CHANNELS (GOROUTINE COMMUNICATION)
================================================================================

PROJECT OVERVIEW:
=================

This section introduces channels, which are Go's mechanism for safely 
communicating between goroutines. Channels replace shared memory as the primary
inter-goroutine communication mechanism. Key concepts include:
- Channel creation and usage
- Sending and receiving data
- Non-buffered channels (blocking)
- Buffered channels
- Channel closing for deadlock prevention

Channels are central to Go's philosophy: "Don't communicate by sharing memory;
share memory by communicating."

TOPIC 1: THE PROBLEM CHANNELS SOLVE
==================================

Without channels, goroutines must share variables:

Problem Approach (Not Recommended):
    var result string  // Shared variable
    
    go func() {
        result = "Hello"  // Goroutine 1 modifies
    }()
    
    fmt.Println(result)  // Main reads (race condition!)

Issues:
- Race conditions (multiple goroutines access same variable)
- Unpredictable behavior
- Memory corruption possible
- Hard to reason about correctness

From main.go Comment:
    "we have the two goroutine and we have to transfer data between them
     then how can we do that. one way is to use the local/package variable
     which will help them transfer data between these, which is not a good Idea."

TOPIC 2: WHAT ARE CHANNELS?
==========================

A channel is a typed, safe pathway for goroutines to communicate.

Definition:
Channels are pipelines through which you can send and receive values between
goroutines. They provide synchronization and communication.

Analogy:
- Think of a postal system
- Send a letter (value) into a mailbox (channel)
- Receiver gets the letter when it arrives
- Only one receive per send

TOPIC 3: CHANNEL CREATION
========================

Declaration and Initialization:

Syntax:
    var channelName chan Type
    channelName = make(chan Type)

Or Combined:
    channelName := make(chan Type)

From main.go:
    var channel chan string      // Declare
    channel = make(chan string)  // Initialize
    
    // Or:
    channel := make(chan string)

Understanding the Syntax:
- chan keyword indicates it's a channel
- string specifies the data type
- make() initializes the channel
- The channel is ready to send/receive strings

TOPIC 4: SENDING AND RECEIVING DATA
===================================

Sending Data:
    channel <- value

The arrow (<-) points in the direction of data flow.
"channel gets value"

Receiving Data:
    value := <-channel

The arrow points in the direction of data flow.
"value gets from channel"

From main.go:
    // Sending
    channel <- "Message passed through channel from this method / goroutine"
    
    // Receiving
    msgFromChanneltoMainChannel := <-channel

Complete Example:
    func sendData(channel chan string) {
        channel <- "Hello"  // Send data
    }
    
    func main() {
        channel := make(chan string)
        
        go sendData(channel)
        
        msg := <-channel  // Receive data - BLOCKING WAIT
        fmt.Println(msg)  // Output: Hello
    }

TOPIC 5: NON-BUFFERED CHANNELS (BLOCKING)
=========================================

Non-buffered channels require synchronization between sender and receiver.

Behavior:
- Send blocks until someone receives
- Receive blocks until someone sends
- Creates natural synchronization

From main.go:
    func printMessage(value string, channel chan string) {
        for i := 0; i < 5; i++ {
            fmt.Println(value)
            time.Sleep(800 * time.Millisecond)
        }
        channel <- "Message passed..."  // Send
    }
    
    func main() {
        channel := make(chan string)    // Non-buffered
        
        go printMessage("Frontend Masters", channel)
        
        msgFromChannel := <-channel     // BLOCKS until message arrives
        fmt.Println(msgFromChannel)
    }

Execution Steps:
1. Main creates channel
2. Main starts goroutine (printMessage)
3. Main calls <-channel (BLOCKS HERE)
4. Goroutine prints 5 times (takes ~4 seconds)
5. Goroutine sends message to channel
6. Main UNBLOCKS, receives message, prints it

From main.go Comment:
    "make the main function wait until the value is recieved."

Benefit:
Automatically synchronizes goroutines without explicit locks.

TOPIC 6: CHANNEL AS SYNCHRONIZATION TOOL
========================================

Beyond data transfer, channels synchronize goroutine completion.

Use Case: Waiting for Goroutine to Complete
    var done chan bool
    done = make(chan bool)
    
    go func() {
        // Do work
        done <- true  // Signal completion
    }()
    
    <-done  // Wait for completion
    // Main blocks until goroutine finishes

From main.go:
    msgFromChanneltoMainChannel := <-channel
    
This blocks until the goroutine sends something - no need for infinite loops!

TOPIC 7: BUFFERED CHANNELS
=========================

Buffered channels can hold multiple values before blocking.

Creating Buffered Channel:
    channel := make(chan Type, bufferSize)

The second parameter is the buffer capacity.

From main.go:
    logs := make(chan string, 2)  // Buffer size = 2
    
    logs <- "First"   // Doesn't block
    logs <- "Second"  // Doesn't block
    logs <- "Third"   // BLOCKS (buffer full)

Buffered vs Non-Buffered:

Non-Buffered:
    logs := make(chan string)
    logs <- "msg"  // Blocks until received
    
Buffered (size 2):
    logs := make(chan string, 2)
    logs <- "msg1"  // Doesn't block (1/2 fullloads)
    logs <- "msg2"  // Doesn't block (2/2 full)
    logs <- "msg3"  // BLOCKS (buffer full)

When to Use:
- Small number of goroutines: Non-buffered
- Many goroutines: Buffered can help
- Decoupling: Buffered reduces synchronization

From main.go:
    logs := make(chan string, 2)
    go goroutineMethod("Hello from main!", logs)
    fmt.Println(<-logs)  // Receive first message
    fmt.Println(<-logs)  // Receive second message

Buffer Benefit:
The goroutine can send both messages quickly without waiting for main to receive.

TOPIC 8: DEFAULT PATTERN - BLOCKING CHANNELS
==============================================

The typical pattern with channels:

Simple Goroutine Communication:
    result := make(chan string)
    
    go func() {
        // Do work
        result <- "computed value"
    }()
    
    value := <-result  // Blocks until goroutine sends

This replaces the infinite loop pattern from goroutines section!

From main.go (if simplified):
    func main() {
        channel := make(chan string)
        
        go printMessage("msg", channel)
        
        msg := <-channel  // Simple waiting mechanism
        fmt.Println(msg)
        // Program ends naturally, no infinite loop
    }

TOPIC 9: DEADLOCKS AND CHANNEL CLOSING
======================================

Deadlock Scenarios:

Scenario 1: Send on Non-Buffered with No Receiver
    msgs := make(chan string)
    msgs <- "hello"  // No one receiving - DEADLOCK
    fmt.Println(<-msgs)

Fixes:
    msgs := make(chan string)
    go func() {
        msgs <- "hello"  // Send in goroutine
    }()
    fmt.Println(<-msgs)  // Receive in main

Scenario 2: Receive on Empty Channel
    msgs := make(chan string)
    fmt.Println(<-msgs)  // Nothing sent - DEADLOCK

Closing Channels:
Use close() to signal no more values coming:

    channel := make(chan string)
    close(channel)

From main.go:
    close(channel)  // closing the channel 'channel'.
    close(logs)     // closing the channel 'logs'.

When to Close:
- When sender is done sending
- Only the sender should close
- Receiving from closed channel returns zero value
- Sending to closed channel panics

Benefits:
- Signals end of communication
- Allows receivers to know when to stop
- Prevents deadlocks
- Proper resource cleanup

TOPIC 10: CHANNEL DIRECTION (SEND/RECEIVE ONLY)
==============================================

Channels can be restricted to send-only or receive-only:

Send-Only Channel:
    func sendData(channel chan<- string) {
        channel <- "data"      // ✓ Send allowed
        msg := <-channel       // ✗ Receive ERROR
    }

Receive-Only Channel:
    func receiveData(channel <-chan string) {
        msg := <-channel       // ✓ Receive allowed
        channel <- "data"      // ✗ Send ERROR
    }

Full Channel:
    channel := make(chan string)  // Bidirectional

Benefits:
- Compiler enforces constraints
- Documents intent in function signature
- Prevents accidental misuse

Common Pattern:
    func worker(jobs <-chan int, results chan<- int) {
        for job := range jobs {
            results <- job * 2
        }
    }

TOPIC 11: BEST PRACTICES WITH CHANNELS
===================================

1. Always Close Channels You Own:
    func producer(out chan<- int) {
        defer close(out)
        for i := 0; i < 5; i++ {
            out <- i
        }
    }

2. Only Sender Closes:
    // receiver NEVER closes
    // sender closes when done

3. Use Buffered for Many Senders:
    done := make(chan bool, numWorkers)
    // Prevents blocking individual senders

4. Use range with Channels:
    for msg := range channel {  // Loops until closed
        fmt.Println(msg)
    }

5. Separate Concerns:
    type Pipeline struct {
        In  <-chan int  // Receive only
        Out chan<- int  // Send only
    }

From main.go Pattern:
    nums := make(chan string, 2)  // Buffered for multiple sends
    go goroutineMethod("msg", nums)
    fmt.Println(<-nums)  // Receive
    fmt.Println(<-nums)  // Receive
    close(nums)          // Close when done

================================================================================
KEY TAKEAWAYS:
================================================================================

1. Channel is a typed, safe communication pipeline between goroutines
2. Send syntax: channel <- value (arrow points to channel)
3. Receive syntax: value := <-channel (arrow points away from channel)
4. Non-buffered channels block until both sender and receiver ready
5. Buffered channels: make(chan Type, bufferSize) hold N values
6. Channels synchronize goroutines without explicit locks
7. close() signals no more values will be sent
8. Deadlock: sender sends but no one receives (with non-buffered)
9. Can make send-only (chan<- Type) or receive-only (<-chan Type) channels
10. Only the sender should close a channel
11. Use range to loop over channel until closed: for v := range ch {}
12. Channels replace shared memory as primary inter-goroutine communication

================================================================================
