================================================================================
SECTION 10: INTERFACES
================================================================================

PROJECT OVERVIEW:
=================

This section introduces interfaces in Go, which define method contracts that types
can fulfill. Interfaces enable polymorphism and composition of behaviors. Key 
concepts include:
- Interface definition syntax
- Implicit interface implementation
- Polymorphism through interfaces
- Collections of different types via interfaces
- Interface as behavior contracts

Interfaces are central to Go's approach to polymorphism without inheritance.

TOPIC 1: WHAT ARE INTERFACES?
===========================

An interface is a set of method signatures without implementation.

Think of Interfaces As:
- Contracts that types must fulfill
- Agreements of behavior, not structure
- Sets of method signatures
- Types can implement multiple interfaces

From interfaces/interfaces.go:
    type Signable interface {
        SignUp() bool  // Method signature only, no implementation
    }

The Interface Says:
"Any type that has a SignUp() method returning bool implements Signable."

TOPIC 2: INTERFACE DEFINITION SYNTAX
===================================

Creating an interface:

Syntax:
    type InterfaceName interface {
        Method1() ReturnType
        Method2(param Type) ReturnType
        Method3() (ReturnType1, ReturnType2)
    }

From interfaces.go:
    type Signable interface {
        SignUp() bool
    }

Key Points:
- Method signatures ONLY (no implementation)
- No method bodies
- Types don't explicitly say they implement interface
- Interface is a contract of behavior

Multiple Methods:
    type Reader interface {
        Read(p []byte) (n int, err error)
    }
    
    type Writer interface {
        Write(p []byte) (n int, err error)
    }
    
    type ReadWriter interface {
        Read(p []byte) (n int, err error)
        Write(p []byte) (n int, err error)
    }

TOPIC 3: IMPLICIT INTERFACE IMPLEMENTATION
==========================================

Go implements interfaces implicitly - no explicit "implements" keyword needed.

If a type has methods matching an interface's signature, it AUTOMATICALLY
implements that interface.

From course.go:
    type Course struct {
        Id   int
        Name string
    }
    
    func (c Course) SignUp() bool {
        return true
    }

From workshop.go:
    type Workshop struct {
        course.Course
        Date time.Time
    }
    
    func (w Workshop) SignUp() bool {
        return true
    }

Both Course and Workshop have SignUp() bool methods, so both automatically
implement the Signable interface without any explicit declaration.

From main.go Comment:
    "IMPLICIT IMPLEMENTATION:
     Where did I set that course and workshop are implementing that interface?
     I'm not saying it anywhere. 'In Go, it's implicit by the name or the
     signature of your interface'. So, if you have any type with that method,
     with that signature you're in, you're in the interface automatically.
     You don't need to say implement 'Signable'."

No "implements" Keyword:
    // Languages like Java:
    class Course implements Signable { ... }
    
    // Go:
    type Course struct { ... }
    func (c Course) SignUp() bool { ... }
    // That's it! Automatically implements Signable

TOPIC 4: USING INTERFACES AS TYPES
==================================

Interfaces can be used as types for variables and collections.

Creating an Interface Variable:
    var obj interfaces.Signable  // obj can hold ANY type that implements Signable

Storing Different Types:
    var courses [2]interfaces.Signable
    courses[0] = goCourse      // Course implements Signable
    courses[1] = jsWorkShop    // Workshop implements Signable

From main.go:
    var courses2 [2]interfaces.Signable
    courses2[0] = goCourse
    courses2[1] = jsWorkShop
    // Now both different types are in the same collection

Benefit:
Before interfaces:
    var courses [2]course.Course  // Only Course type allowed
    courses[0] = goCourse
    // courses[1] = jsWorkShop     // ERROR: jsWorkShop is not course.Course

With interfaces:
    var courses2 [2]interfaces.Signable  // Any type with SignUp() allowed
    courses2[0] = goCourse
    courses2[1] = jsWorkShop  // Works! Both implement Signable

TOPIC 5: POLYMORPHISM THROUGH INTERFACES
========================================

Polymorphism: ability to call the same method on different types.

Looping Over Interface Collection:
    for _, courseAndWorkShop := range courses2 {
        fmt.Println(courseAndWorkShop)
    }

What Happens:
1. Iterate through array of Signable (interface type)
2. Each element could be Course or Workshop
3. Call methods available on Signable interface
4. Actual method called depends on runtime type

From main.go:
    var courses2 [2]interfaces.Signable
    courses2[0] = goCourse
    courses2[1] = jsWorkShop
    
    for _, courseAndWorkShop := range courses2 {
        fmt.Println(courseAndWorkShop)  // Works even though different types
    }

Method Dispatch:
When you call courseAndWorkShop.SignUp():
- If it's Course, calls Course.SignUp()
- If it's Workshop, calls Workshop.SignUp()
- Determined at runtime, not compile time

TOPIC 6: INTERFACE METHOD MATCHING
=================================

A type implements an interface if it has all required methods with matching
signatures.

Method Signature Requirements:
- Method name must match EXACTLY
- Parameter types must match EXACTLY
- Parameter count must match
- Return types must match EXACTLY

Interface:
    type Writer interface {
        Write(data string) int
    }

Types That Implement:
    func (f File) Write(data string) int { ... }       // ✓ Matches
    func (b Buffer) Write(data string) int { ... }     // ✓ Matches
    func (l Logger) Write(data string) int { ... }     // ✓ Matches

Types That DON'T Implement:
    func (f File) Write(data int) int { ... }          // ✗ Wrong param type
    func (b Buffer) Write(data string) { ... }         // ✗ Wrong return type
    func (l Logger) WriteData(data string) int { ... } // ✗ Wrong name

TOPIC 7: EMPTY INTERFACE
=======================

An interface with no methods is the empty interface.

Syntax:
    interface{}

Special Properties:
- Every type implements the empty interface
- Can hold ANY type
- Like "any" or "Object" in other languages

Common Uses:
    var x interface{}
    x = 5                    // int
    x = "hello"              // string
    x = Course{}             // Any struct
    x = []int{1, 2, 3}       // Any slice

Type Assertion (To retrieve original type):
    str := x.(string)        // Assert x is string
    num, ok := x.(int)       // Safe assertion
    if ok { ... }

When to Use:
- Generic functions that work with any type
- Flexible data structures
- When type is unknown at compile time

From interfaces.go, Signable interface:
    type Signable interface {
        SignUp() bool
    }

Non-empty interface (requires specific method).

TOPIC 8: INTERFACE AS BEHAVIOR CONTRACT
======================================

Interfaces represent behavior, not structure.

Wrong Thinking:
    "What data does the type have?"
    
Right Thinking:
    "What can the type DO?"

Example:
    // Focuses on structure:
    type FileReader struct {
        data []byte
    }
    
    // Focuses on behavior:
    type Reader interface {
        Read(p []byte) (n int, err error)
    }

From Code:
    type Signable interface {
        SignUp() bool
    }
    
This Says:
    "Anything you can call SignUp() on is Signable."
    
Not:
    "Signable has specific fields."

Benefits:
1. Decouples from specific types
2. Enables testing with mock objects
3. Allows multiple implementations
4. Simplifies APIs

TOPIC 9: INTERFACE COMPOSITION
=============================

Interfaces can contain other interfaces.

Syntax:
    type ReadWriter interface {
        Reader
        Writer
    }

Is Equivalent To:
    type ReadWriter interface {
        Read(p []byte) (n int, err error)
        Write(p []byte) (n int, err error)
    }

Benefits:
- Avoid repeating method signatures
- Build larger behaviors from smaller ones
- More modular interface design

From course.go and workshop.go:
Both separately implement Signable, rather than having a larger interface that combines them.

TOPIC 10: WORKING WITH INTERFACES - BEST PRACTICES
===============================================

1. Define Small Interfaces:
    type Reader interface {
        Read(p []byte) (n int, err error)
    }
    // Better than huge interface with 20 methods

2. Use Interface Parameters:
    // Instead of:
    func Process(c Course) { ... }
    
    // Use:
    func Process(s Signable) { ... }
    // Now works with any Signable type

3. Accept Interfaces, Return Concrete Types:
    func New() Course { ... }        // Returns concrete type
    func Process(s Signable) { ... } // Accepts interface

4. Name Interfaces with "-able" or "-er":
    type Reader interface { ... }
    type Writer interface { ... }
    type Signable interface { ... }

5. Keep Interfaces Small:
    Single responsibility principle applies to interfaces too.
    One interface = one concept

TOPIC 11: REAL-WORLD INTERFACE PATTERNS
======================================

Pattern 1: Plugin Architecture
    type Plugin interface {
        Init() error
        Execute() error
        Shutdown() error
    }
    
    // Many different plugin types can implement this

Pattern 2: Testing with Mocks
    type Database interface {
        Query(sql string) (Result, error)
    }
    
    // Real implementation: PostgreSQL, MySQL
    // Mock implementation: InMemory for testing

Pattern 3: Configuration
    type Configuration interface {
        Get(key string) string
        Set(key string, value string) error
    }
    
    // Implementations: FileConfig, EnvConfig, DatabaseConfig

Pattern 4: Writer Abstraction
    type Writer interface {
        Write(p []byte) (n int, err error)
    }
    
    // Implementations: File, Buffer, Network, Compressed

From Code:
    type Signable interface {
        SignUp() bool
    }
    
    // Course and Workshop both implement
    // Can be used interchangeably in collections and functions

================================================================================
KEY TAKEAWAYS:
================================================================================

1. Interface is a set of method signatures without implementation
2. Types automatically implement interfaces if they have matching methods
3. No explicit "implements" keyword needed - implementation is implicit
4. Use interfaces as types for variables: var obj InterfaceName
5. Interfaces enable polymorphism: different types, same interface type
6. A type can implement multiple interfaces
7. Empty interface {} accepts any type
8. Interfaces represent behavior (what can be done), not structure
9. Define small, focused interfaces with one responsibility
10. Accept interfaces as parameters, return concrete types
11. Methods dispatched at runtime based on actual type
12. Great for testing with mock implementations

================================================================================
