================================================================================
SECTION 11: GOROUTINES (LIGHTWEIGHT THREADING)
================================================================================

PROJECT OVERVIEW:
=================

This section introduces goroutines, which are Go's approach to concurrent 
programming. Goroutines are lightweight threads that allow functions to run
concurrently. Key concepts include:
- Creating goroutines with the "go" keyword
- Application lifecycle and goroutines
- The time package for delays
- Shared memory across goroutines
- Why we need synchronization

Goroutines are fundamental to Go's concurrency model.

TOPIC 1: WHAT IS A GOROUTINE?
===========================

A goroutine is a lightweight thread of execution managed by the Go runtime.

Definition:
A goroutine is the Go way of implementing threading - concurrent execution of code.

Key Characteristics:
- Cost: Much smaller than OS threads
- Management: Managed by Go runtime, not OS
- Quantity: Can create thousands without performance issues
- Speed: Very quick to create and destroy
- Simplicity: Extremely simple syntax

Traditional Threading vs Goroutines:
- OS Threads: Heavy, slow to create, limited quantity
- Goroutines: Lightweight, fast to create, can run thousands

From main.go Comment:
    "Goroutines, we're going to make an intro on this...
     A goroutine is the Go way of using threads.
     Go was created from scratch in the modern way to solve current problems...
     it's much simpler."

TOPIC 2: THE "GO" KEYWORD
=======================

Creating a goroutine is as simple as prefixing a function call with "go".

Syntax:
    go functionName(arguments)

Sequential Execution (Current Function):
    func main() {
        printMessage("Hello")
        printMessage("World")
    }
    
    // Execution:
    // First printMessage("Hello") runs completely
    // Then printMessage("World") runs
    // Sequential and blocking

From main.go:
    printMessage("Golang is Best!")        // Sequential
    printMessage("Hello, Everyone!")       // Waits for first to complete

Concurrent Execution (With Goroutines):
    func main() {
        go printMessage("Hello")
        go printMessage("World")
    }
    
    // Execution:
    // Both printMessage calls run "at the same time"
    // Output is interleaved from both

From main.go:
    go printMessage("Golang is the Great!")
    go printMessage("Typescript is the Great!")
    go printMessage("Js is great!")

Multiple goroutines run concurrently, creating interleaved output.

TOPIC 3: TIME.SLEEP() FOR DELAYS
===============================

The time package provides Sleep() for waiting/pausing execution.

Import:
    import "time"

Syntax:
    time.Sleep(duration)

Duration Units:
Go's Duration type uses nanoseconds as the base unit, but provides constants:
    time.Nanosecond
    time.Microsecond
    time.Millisecond
    time.Second
    time.Minute
    time.Hour

Creating Durations:
    time.Sleep(1 * time.Second)          // 1 second
    time.Sleep(500 * time.Millisecond)   // 500 milliseconds
    time.Sleep(800 * time.Millisecond)   // 800 milliseconds

From main.go:
    func printMessage(text string) {
        for i := 0; i < 5; i++ {
            fmt.Println(text)
            time.Sleep(800 * time.Millisecond)  // Wait 800ms each iteration
        }
    }

Why Durations?
    // Without time package constants:
    time.Sleep(800000000)  // 800 million nanoseconds (confusing!)
    
    // With constants:
    time.Sleep(800 * time.Millisecond)  // Clear intent

TOPIC 4: APPLICATION LIFECYCLE
=============================

Critical Rule: The program ends when the MAIN goroutine ends.

Main Goroutine:
- Every Go program has one main goroutine
- It executes the main() function
- When main() returns, the entire program terminates

Sequential Program:
    func main() {
        printMessage("A")  // Takes ~4 seconds (5 messages * 800ms)
        printMessage("B")  // Takes ~4 seconds
        // Total: ~8 seconds
        // Program ends when main() exits
    }

Goroutine Program (WRONG):
    func main() {
        go printMessage("A")  // Starts goroutine A
        go printMessage("B")  // Starts goroutine B
        // main() finishes immediately!
    }
    // Program ends before A and B output anything!
    // Goroutines don't block main

From main.go Comment:
    "And what's the lifecycle of my app? When my app ends?
     When my Go app ends? My app ends when the main Goroutine ends.
     When the main Go routine ends when it reaches the end of the main function.
     Now I'm opening three more Goroutines. So I have the main goroutine and
     three more goroutines that they are doing their job. But the main one has
     nothing else to do after that. So the whole process end, okay?"

TOPIC 5: KEEPING MAIN ALIVE
===========================

Solution 1: Infinite Loop (Not Recommended)
    func main() {
        go printMessage("A")
        go printMessage("B")
        for {}  // Infinite loop keeps main alive forever
    }
    
    Problems:
    - Program never ends naturally
    - Must use Ctrl+C to stop
    - Wastes CPU cycles

From main.go:
    go printMessage("Golang is the Great!")
    for {  // inifinite loop, to keep the main function busy
    }

Solution 2: Time.Sleep (Temporary)
    func main() {
        go printMessage("A")
        go printMessage("B")
        time.Sleep(10 * time.Second)  // Wait 10 seconds
    }
    
    Problems:
    - Must guess how long to wait
    - If too short, goroutines don't finish
    - If too long, wasting time
    - Not reliable

Solution 3: Channels (Best, see next section)
    func main() {
        done := make(chan bool)
        go func() {
            printMessage("A")
            done <- true  // Signal completion
        }()
        <-done  // Wait for completion
    }

TOPIC 6: CONCURRENT EXECUTION
=============================

When goroutines run, their execution is interleaved.

Sequential Output (Original):
    func main() {
        printMessage("Message 1")
        printMessage("Message 2")
    }
    
    Output (in order):
    Message 1
    Message 1
    Message 1
    Message 1
    Message 1
    [waits 4 seconds]
    Message 2
    Message 2
    Message 2
    Message 2
    Message 2

Concurrent Output (With goroutines):
    func main() {
        go printMessage("Message 1")
        go printMessage("Message 2")
        for {}
    }
    
    Output (interleaved):
    Message 1
    Message 2
    Message 1
    Message 1
    Message 2
    Message 2
    Message 1
    Message 2
    ...

From main.go:
    go printMessage("Golang is the Great!")
    go printMessage("Typescript is the Great!")
    go printMessage("Js is great!")
    for {}
    
    // Output interleaves from all three messages

The Interleaving:
- Both goroutines start
- Execution alternates between them
- Sometimes goroutine A runs, sometimes B
- Feels like parallel execution
- On multi-core systems, truly parallel

TOPIC 7: SHARED MEMORY ACROSS GOROUTINES
========================================

Goroutines in the same process share memory.

Global Variables:
    var counter = 0
    
    func increment() {
        counter++
    }
    
    func main() {
        go increment()  // Goroutine 1
        go increment()  // Goroutine 2
        // Both increment the SAME counter variable
    }

Shared Space:
- Package-level variables are shared
- Modifications in one goroutine visible in others
- Can cause race conditions

From main.go Comment:
    "They're using the same shared space, which may lead to some problems
     with memory management. What happens if one of those Goroutines is
     saving a value on a variable that other Goroutines at the same time
     trying to read the value, okay? You can lock and unlock and do things
     but there is a better way."

Race Condition Example:
    var x = 0
    
    // Goroutine 1:
    x = 1
    
    // Goroutine 2 (simultaneous):
    print(x)  // Could print 0 or 1 (unpredictable!)

Solution:
- Use channels (see next section)
- Use mutex locks (synchronization)
- Avoid shared state

TOPIC 8: GOROUTINE SCOPE
=======================

When you create a goroutine, all called functions run in that goroutine.

Example:
    func helper() {
        fmt.Println("Running in...")
    }
    
    func wrapper() {
        helper()  // Runs in same goroutine
    }
    
    func main() {
        go wrapper()  // Creates new goroutine
        // helper() and wrapper() both run in that goroutine
        for {}
    }

From main.go Comment:
    "So when you open a Goroutine, everything that is being executed from
     that line will be executed in that Goroutine. So when you call a, you
     don't need to add Go again. If you do that, you are opening another
     Goroutine, okay, so no need for that. Just to call the function, we
     actually continue on that Goroutine."

Important:
- Adding "go" multiple times creates multiple goroutines
- Adding "go" once affects all subsequent function calls
- Function calls from goroutine stay in that goroutine

TOPIC 9: THREAD EXECUTION CONCEPT
================================

Understanding "threads" and execution:

What is a Thread?
An execution path through code that can run independently.

Multithreading:
Multiple execution paths running at the same time (or seemingly so).

Multi-Core Systems:
- True parallel execution on multiple CPU cores
- Multiple threads run simultaneously on different cores

Single-Core Systems:
- Threads appear to run simultaneously
- Actually context-switching rapidly
- OS scheduler decides which thread runs when

From main.go Comment:
    "A thread, is execution line which we can run more than one at the same
     time. Sometimes, they are being executed at the same time or It depends
     on the west, it depends on if you're multicore, if they're actually
     really running at the same time or its speaking from one or the other.
     Anyway, it feels like we have different lines of execution running at
     the same time."

TOPIC 10: PRACTICAL EXAMPLE - SEQUENTIAL VS CONCURRENT
==================================================

Sequential Execution:
    func main() {
        printMessage("Golang")  // 4 seconds
        printMessage("TypeScript")  // 4 seconds
        // Total: ~8 seconds
    }

Concurrent Execution:
    func main() {
        go printMessage("Golang")     // 4 seconds
        go printMessage("TypeScript") // 4 seconds (in parallel)
        for {}  // Total: ~4 seconds
    }

Performance Benefit:
- Sequential: Sum of all durations
- Concurrent: Max of all durations (when I/O bound)

TOPIC 11: WHEN TO USE GOROUTINES
===============================

Good Use Cases:
1. I/O Operations - Network requests, file reading
2. Concurrent Tasks - Processing multiple items
3. Long-Running Tasks - Background jobs
4. Non-Blocking UI - Keep interface responsive
5. Server Requests - Handle multiple clients

From code:
    // Multiple messages printing "concurrently"
    go printMessage("Message A")
    go printMessage("Message B")
    // Both run at the same time

Bad Use Cases:
1. CPU-Intensive Tasks - Use other parallelization (not goroutines alone)
2. Simple Sequential Code - Overcomplicated
3. When Ordering Matters - Hard to ensure sequence

================================================================================
KEY TAKEAWAYS:
================================================================================

1. Goroutine is Go's lightweight thread created with "go" keyword
2. Syntax: go functionName(args)
3. Program ends when main() finishes - other goroutines terminate too
4. Goroutines are very cheap to create (unlike OS threads)
5. time.Sleep() pauses execution: time.Sleep(800 * time.Millisecond)
6. Use time.Second, time.Millisecond constants for clarity
7. Keep main alive with infinite loop or channels (channels are better)
8. Goroutines share memory - can cause race conditions
9. Execution order is unpredictable - leads to interleaved output
10. Functions called from goroutine continue in that goroutine
11. Concurrent execution is much faster for I/O-bound operations
12. Need synchronization (channels or mutex) for safe shared state

================================================================================
