================================================================================
SECTION 04: READING FILES
================================================================================

PROJECT OVERVIEW:
=================

This section demonstrates reading file contents from the filesystem in Go.
Key concepts include:
- Opening and reading files
- Handling file read errors
- Converting bytes to strings
- Working with file paths

This is essential for any application that needs to process external files.

TOPIC 1: OS PACKAGE
===================

Go provides the "os" package for operating system operations including file I/O.

Import:
    import "os"

Most Common Functions:
- os.ReadFile(filename) - Read entire file content
- os.Getwd() - Get current working directory
- os.Open(filename) - Open file (for more control)

TOPIC 2: READING ENTIRE FILES
=============================

The os.ReadFile() function reads the complete file into memory:

Syntax:
    content, err := os.ReadFile(filename)

Returns Two Values:
1. content - byte slice []byte containing file data
2. err - error object (nil if successful)

Example from main.go:
    content, err := os.ReadFile("./text.txt")

Where:
- "./text.txt" is the relative path to the file
- content will be a []byte with the file contents
- err will be the error (if any)

TOPIC 3: ERROR HANDLING FOR FILE OPERATIONS
============================================

File operations always return an error as the second value.

Check for Errors:
    content, err := os.ReadFile(filename)
    if err != nil {
        // File not found, permission denied, etc.
        // Handle the error
    } else {
        // File read successfully
        // Process content
    }

From main.go:
    content, err := readTextFiles("./text.txt")
    if err != nil {
        fmt.Printf("error happened : %v", err)
        panic(err)  // Stop execution
    } else {
        fmt.Println(content)  // Print contents
    }

Error Handling Approaches:

1. Return Error:
       func readTextFiles(filename string) (string, error) {
           content, err := os.ReadFile(filename)
           if err != nil {
               return "", err  // Return empty string and the error
           }
           return string(content), nil  // Success: error is nil
       }

2. Print and Panic:
       if err != nil {
           fmt.Println("We can't read the file.")
           panic(err)  // Stops execution
       }

3. Print and Continue:
       if err != nil {
           fmt.Println("We can't read the file.")
           // Continue with default values
       }

TOPIC 4: BYTE SLICES vs STRINGS
==============================

os.ReadFile() returns a byte slice, not a string.

Byte Slice:
    content, err := os.ReadFile(filename)
    // content is type []byte - array of bytes

String:
    string(content)  // Convert []byte to string

From main.go:
    content, err := os.ReadFile(filename)
    // content is []byte
    
    return string(content), nil  // Convert to string for return

Why This Matters:
- Files on disk are stored as bytes
- Strings are text representations
- Go requires explicit conversion between them
- string(byteSlice) performs UTF-8 decoding

Example:
    File contents (as bytes): [72 101 108 108 111]
    Converted to string: "Hello"

TOPIC 5: FILE PATH OPERATIONS
=============================

Getting Current Working Directory:
    rootPath, _ := os.Getwd()
    fmt.Println(rootPath)  // Prints current directory

From main.go:
    rootPath, _ := os.Getwd()
    // _ ignores the error if any
    // rootPath contains the current working directory path

Example Output (on Windows):
    C:\Users\Username\go\s04_readingFiles

Example Output (on Mac/Linux):
    /Users/username/go/s04_readingFiles

Relative Paths:
    "./text.txt"  // Current directory
    "../other/file.txt"  // Parent directory
    "subdir/file.txt"  // Subdirectory

Absolute Paths:
    "C:\\Users\\file.txt"  // Windows (with escaped backslashes)
    "/home/user/file.txt"  // Unix

TOPIC 6: FUNCTION SIGNATURE FOR FILE READING
============================================

The readTextFiles function demonstrates proper file reading:

    func readTextFiles(filename string) (string, error) {
        content, err := os.ReadFile(filename)
        if err != nil {
            fmt.Println("We can't read the file.")
            return "", err  // Return with error
        } else {
            return string(content), nil  // Return with nil error (success)
        }
    }

Parameters:
- filename: string - The path to the file to read

Return Values:
- string - The file contents as a string (empty if error)
- error - The error object (nil if successful)

This signature follows Go's error handling pattern.

Usage:
    content, err := readTextFiles("./text.txt")
    if err != nil {
        // Handle error
    } else {
        // Use content
    }

TOPIC 7: COMPLETE FILE READING FLOW
==================================

Step-by-Step Execution:

1. Call the function:
       content, err := readTextFiles("./text.txt")

2. Inside function, read the file:
       content, err := os.ReadFile(filename)

3. Check for errors:
       if err != nil {
           return "", err  // Return error to caller
       }

4. Convert bytes to string:
       return string(content), nil  // nil means no error

5. In main, check if successful:
       if err != nil {
           // Handle error
           panic(err)
       } else {
           // Use the content
           fmt.Println(content)
       }

Complete Example:
    func readTextFiles(filename string) (string, error) {
        content, err := os.ReadFile(filename)  // [1] Read file
        if err != nil {                        // [2] Check error
            return "", err                     // [3] Return error
        }
        return string(content), nil            // [4] Return success
    }
    
    func main() {
        content, err := readTextFiles("./text.txt")  // [5] Call function
        if err != nil {                              // [6] Check error
            panic(err)                               // [7] Handle error
        }
        fmt.Println(content)                         // [8] Use content
    }

TOPIC 8: IGNORING RETURN VALUES
==============================

When you don't care about a return value, use the blank identifier (_):

    rootPath, _ := os.Getwd()
    // _ ignores any error from Getwd()

This is useful when:
- You're confident the operation will succeed
- Error is not critical for continuing
- You want to suppress compiler warnings about unused variables

Example:
    content, _ := os.ReadFile("file.txt")
    // Ignores any error that occurred

Note: This is NOT best practice - it's better to handle errors properly.

TOPIC 9: PANIC IN ERROR HANDLING
=======================================

The panic() function can be called to stop execution:

    if err != nil {
        panic(err)  // Stop execution with error message
    }

From main.go:
    if err != nil {
        fmt.Printf("error happened : %v", err)
        panic(err)  // Program terminates here
    }

Execution Flow:
1. If error occurs, print message
2. Call panic(err)
3. Program terminates
4. Error message is displayed

Output Example:
    error happened : open ./text.txt: no such file or directory
    panic: open ./text.txt: no such file or directory
    ...stack trace...

When to Use panic():
- File not found (critical)
- Permission denied (critical)
- Not applicable for recoverable errors

TOPIC 10: SAMPLE FILE CONTENT
============================

From text.txt:
    I am the content of the text file.

When this file is read by the program:
    
    func main() {
        content, err := readTextFiles("./text.txt")
        if err == nil {
            fmt.Println(content)
        }
    }
    
Output:
    I am the content of the text file.

The entire file content is read as a string.

TOPIC 11: MULTIPLE RETURN VALUE PATTERNS
========================================

Go's multiple return values enable clean error handling.

Pattern 1: Value and Error
    func read(filename string) (string, error) {
        // ...
        return "", err
    }

Pattern 2: Value and Boolean
    func find(key string) (value int, found bool) {
        // ...
        return 0, false
    }

Pattern 3: Multiple Values Same Type
    func divide(a, b int) (quotient, remainder int) {
        return a/b, a%b
    }

File operations almost always use Pattern 1 (value, error).

================================================================================
KEY TAKEAWAYS:
================================================================================

1. os.ReadFile(filename) reads entire file content as []byte
2. Always check the error return value: if err != nil { ... }
3. Convert []byte to string with string(byteSlice)
4. os.Getwd() returns current working directory
5. Use relative paths like "./file.txt" for files in current directory
6. File reading functions return (content, error) pattern
7. panic(err) stops execution immediately
8. _ ignores unwanted return values but shouldn't hide errors
9. Functions can return multiple values including errors
10. Go's error handling is explicit - no exceptions/try-catch
11. Files are stored as bytes; strings need conversion
12. Proper error handling should inform users what went wrong

================================================================================
